/*
 * @Author: Latte
 * @Date: 2022-02-23 08:38:22
 * @LAstEditors: Latte
 * @LastEditTime: 2022-02-23 11:55:21
 * @FilePath: \algorithm\110. 平衡二叉树.js
 */

/**
 * 首先，我们需要明确二叉树高度和深度的区别
 * 高度：高度是值该节点到叶子节点的最长简单路径边的条数
 * 深度：深度是指该节点到根节点的最最长简单路径边的条数
 * 总结：
 * 1.树的高度和深度是一致的
 * 2.同一层级的节点深度是一样的，但是高度不一定相同
 *
 * 思路：自底向上的递归
 * 递归三部曲：
 * 1.确定递归函数的参数和返回值
 * 参数为传入的节点的指针
 * 返回值：
 * 如果以传入节点为根节点的树是平衡二叉树。那么返回高度（其高度为左右子树中的最大高度 + 1）
 * 如果不是平衡二叉树，那么返回 -1 作为一个 flag
 * 
 * 2.确定递归的终止条件
 * 递归的过程中，如果当前节点为空，表示以当前节点为根节点的树高度为0，返回 0
 * 
 * 3.明确单层递归逻辑
 * 如何判断当前传入节点为根节点的二叉树是否为平衡二叉树呢。当然是左子树和右子树绝对高度差
 * 分别求出左右子树的高度，如果差值大于1或者左子树不是平衡二叉树或者右子树不是平衡二叉树，返回 -1，否则返回当前二叉树的高度
 */

var isBalanced = function (root) {
	return balanced(root) !== -1;
};
var balanced = function (node) {
  // 当前节点为空，高度表示为0
	if (!node) return 0;
  // 求左子树的高度
	const left = balanced(node.left);
  // 求右子树的高度
	const right = balanced(node.right);

  
	if (left === -1 || right === -1 || Math.abs(left - right) > 1) { // 当前左子树/右子树不是平衡二叉树 或者 左右子树的绝对高度差大于 1，表示当前二叉树不是平衡二叉树，返回 -1
		return -1;
	}
  // 否则返回当前二叉树的高度（左右子树中的最大高度 + 1）
	return Math.max(left, right) + 1;
};
